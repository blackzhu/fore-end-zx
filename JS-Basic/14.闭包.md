## 前言

和闭包有关的知识点：作用域（执行上下文），垃圾回收机制

参考冴羽的文章和追梦子的

[JavaScript深入之闭包 ](https://github.com/mqyqingfeng/Blog/issues/9)

[汤姆大叔必包](https://www.cnblogs.com/TomXu/archive/2012/01/31/2330252.html)

在汤姆大叔的作用域链中提到必包，需要了解为什么要必包。   
因为词法作用域导致一些问题： —— 是否将函数以返回值返回（第一类问题）以及是否将函数当函数参数使用（第二类问题）。

tom大叔总结到：

1.所有的函数都是闭包，因为它们都是在创建的时候就保存了上层上下文的作用域链

2.所有的内部函数都共享同一个父作用域

3.因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD都是闭包）。只有一类函数除外，那就是通过Function构造器创建的函数，因为其[[Scope]]只包含全局对象。

从实践角度：以下函数才算是闭包：

  * 1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）  
  * 2.在代码中引用了自由变量 

[初始闭包](https://www.cnblogs.com/pssp/p/5189345.html)

如果某个函数被它的父函数之外的一个变量引用，保存了作用域链（冴羽文章中提到维护作用域链），就形成了一个闭包



[js闭包，作用域，this](https://www.cnblogs.com/pssp/p/5781090.html)

[从闭包案例中学习闭包](https://www.cnblogs.com/pssp/p/5224509.html)


